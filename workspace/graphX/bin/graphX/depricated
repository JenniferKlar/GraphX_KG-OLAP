	private static Graph<Object, Relation> groupByPropertyOld(Graph<Object, Relation> quadGraph, JavaSparkContext jsc,
			ClassTag<Object> objectTag, ClassTag<Relation> relationTag, String groupingProperty,
			String groupingPredicate, String mod) {

		List<String> groups = quadGraph.triplets().toJavaRDD()
				.filter(x -> x.attr().getRelationship().toString().contains(groupingProperty))
				.map(x -> x.dstAttr().toString()).distinct().collect();
		
		List<Tuple2<Object, Object>> currentVertices = new ArrayList<>(quadGraph.vertices().toJavaRDD().collect());
		
		Set<Edge<Relation>> newEdges = new LinkedHashSet<>();
		
		Relation newRelation = new Relation(groupingPredicate, mod, "Resource");

		groups.forEach(x -> {
			// create and add new Vertex
			Resource newResource = new Resource(x + "-Group");
			Tuple2<Object, Object> newVertice = new Tuple2<Object, Object>(
					quadGraph.vertices().count() + groups.indexOf(x), newResource);
			currentVertices.add(newVertice);
			// reference to grouping
			// all individuals with the same property e.g. operationalStatus
			List<Long> verticesToBeReplaced = quadGraph.triplets().toJavaRDD()
					.filter(y -> y.dstAttr().toString().contains(x)).map(y -> y.srcId()).collect();
					
			verticesToBeReplaced.forEach(y -> {
				Edge<Relation> newEdge = new Edge<Relation>(y, quadGraph.vertices().count() + groups.indexOf(x),
						newRelation);
				newEdges.add(newEdge);
								
				// edges to keep
				List<Edge<Relation>> keepEdges = quadGraph.triplets().toJavaRDD()
						.filter(z -> (z.srcId() != y && z.dstId() != y)
						&& (z.attr().getRelationship().toString().contains(groupingProperty)
						|| z.attr().getRelationship().toString().contains("http://www.w3.org/1999/02/22-rdf-syntax-ns#type")))
						.map(z -> new Edge<Relation>(z.srcId(), z.dstId(), z.attr())).collect();
								
				// add new Triples where individuals are replaced by grouping
				List<Edge<Relation>> edgesToAdd = new ArrayList<>();
				edgesToAdd.addAll(quadGraph.triplets().toJavaRDD()
						.filter(z -> z.srcId() == (y)
						&& !z.attr().getRelationship().toString().contains(groupingProperty)
						&& !z.attr().getRelationship().toString().contains("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"))
						.map(z -> new Edge<Relation>((long) newVertice._1, z.dstId(), z.attr())).collect());
				
				edgesToAdd.addAll(quadGraph.triplets().toJavaRDD()
						.filter(z -> z.dstId() == (y)
						&& !z.attr().getRelationship().toString().contains(groupingProperty)
						&& !z.attr().getRelationship().toString().contains("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"))
						.map(z -> new Edge<Relation>(z.srcId(),(long) newVertice._1, z.attr())).collect());
				newEdges.addAll(edgesToAdd);
				newEdges.addAll(keepEdges);
			});
		});

		List<Edge<Relation>> edgeList = new ArrayList<Edge<Relation>>(newEdges);

		Graph<Object, Relation> graph = Graph.apply(jsc.parallelize(currentVertices).rdd(),
				jsc.parallelize(edgeList).rdd(), "", StorageLevel.MEMORY_ONLY(), StorageLevel.MEMORY_ONLY(), objectTag,
				relationTag);
		return graph;

	}

	private static Graph<Object, Relation> aggregatePropertyValuesOld(Graph<Object, Relation> quadGraph, JavaSparkContext jsc,

			ClassTag<Object> objectTag, ClassTag<Relation> relationTag, String aggregateProperty,
			String mod, String aggregateType) {
		JavaRDD<String> verticesRDD = quadGraph.triplets().toJavaRDD()
				.filter(x -> x.attr().getRelationship().toString().equals(aggregateProperty))
				.map(x -> x.srcAttr().toString());
		List<String> vertices = verticesRDD.distinct().collect();

		List<Tuple2<Object, Object>> currentVertices = new ArrayList<>(quadGraph.vertices().toJavaRDD().collect());
		Set<Edge<Relation>> newEdges = new LinkedHashSet<>();

		vertices.forEach(x -> {
				// only size 1
			Long sum = quadGraph.triplets().toJavaRDD()
						.filter(z -> z.srcAttr().toString().contains(x)
								&& z.attr().getRelationship().toString().equals(aggregateProperty)
								&& z.attr().getTargetDataType() != "Resource")
						.map(z -> Long.parseLong(z.dstAttr().toString())).reduce((a,b) -> a+b);
			Long count = quadGraph.triplets().toJavaRDD()
					.filter(z -> z.srcAttr().toString().contains(x)
							&& z.attr().getRelationship().toString().equals(aggregateProperty)).count();

			Long value = null;
			if (aggregateType.contains("AVG")) {
				value = sum / count;
			}
			if (aggregateType.contains("COUNT")) {
				value = count;
			}
			if (aggregateType.contains("SUM")) {
				value = sum;
			}
			if (aggregateType.contains("MIN")) {
				value = quadGraph.triplets().toJavaRDD()
						.filter(z -> z.srcAttr().toString().contains(x)
								&& z.attr().getRelationship().toString().contains(aggregateProperty))
						.map(z -> Long.parseLong(z.dstAttr().toString())).min(Comparator.naturalOrder());
			}
			if (aggregateType.contains("MAX")) {
				value = quadGraph.triplets().toJavaRDD()
						.filter(z -> z.srcAttr().toString().contains(x)
								&& z.attr().getRelationship().toString().contains(aggregateProperty))
						.map(z -> Long.parseLong(z.dstAttr().toString())).max(Comparator.naturalOrder());
			}
			
			String literal = Long.toString(value);
			Tuple2<Object, Object> newVertice = new Tuple2<Object, Object>(
					quadGraph.vertices().count() + vertices.indexOf(x), literal);
			currentVertices.add(newVertice);
			
			// new edge with old vertice and new value..
			Long verticeID = getVerticeId(quadGraph, x);
			Edge<Relation> newEdge = new Edge<Relation>(verticeID,
					quadGraph.vertices().count() + vertices.indexOf(x),
					new Relation(aggregateProperty, mod, Double.class.getSimpleName().toString()));
			newEdges.add(newEdge);
		});
		
		List<Edge<Relation>> removeTriplets = quadGraph.triplets().toJavaRDD()
				.filter(x -> x.attr().getRelationship().toString().equals(aggregateProperty))
				.map(x -> new Edge<Relation>(x.srcId(), x.dstId(), x.attr())).collect();

		List<Edge<Relation>> edgeList = new ArrayList<Edge<Relation>>();
		edgeList.addAll(quadGraph.edges().toJavaRDD().collect());
		edgeList.removeAll(removeTriplets);
		edgeList.addAll(newEdges);

		Graph<Object, Relation> graph = Graph.apply(jsc.parallelize(currentVertices).rdd(),
				jsc.parallelize(edgeList).rdd(), "", StorageLevel.MEMORY_ONLY(), StorageLevel.MEMORY_ONLY(), objectTag,
				relationTag);
		return graph;
	}
	
	private static Graph<Object, Relation> replaceByGroupingOld(Graph<Object, Relation> quadGraph, JavaSparkContext jsc,
			ClassTag<Object> objectTag, ClassTag<Relation> relationTag, String toBeReplaced, String groupingValue) {
		// get instances of the type (subjects) that has to be replaced (that hace "toBeReplaced" as object)
		
		List<String> verticesToBeReplaced = quadGraph.triplets().toJavaRDD()
				.filter(x -> x.dstAttr().toString().contains(toBeReplaced)).map(x -> x.srcAttr().toString()).collect();		
		
		List<Edge<Relation>> edges = new ArrayList<Edge<Relation>>();

		verticesToBeReplaced.forEach(x -> {
			//get the grouping object that should replace the current subject
			 Long groupingId = quadGraph.triplets().toJavaRDD()
					.filter(y -> y.srcAttr().toString().contains(x)
							&& y.attr().getRelationship().toString().contains(groupingValue))
					.map(y -> y.dstId()).first();

			//new triples to add to the graph (with object that replaces the current subject, not type, not groupingValue
			JavaRDD<Edge<Relation>> subjectTriplets = quadGraph.triplets().toJavaRDD()
					.filter(y -> y.srcAttr().toString().contains(x)
							&& !y.attr().getRelationship().toString().contains("http://www.w3.org/1999/02/22-rdf-syntax-ns#type")
							&& !y.attr().getRelationship().toString().contains(groupingValue))
					.map(y -> new Edge<Relation>((long) groupingId, y.dstId(), y.attr()));
			
			//add new triplets where object is replaced
			JavaRDD<Edge<Relation>> objectTriplets = quadGraph.triplets().toJavaRDD()
					.filter(y -> y.dstAttr().toString().contains(x)
							&& !y.attr().getRelationship().toString().contains("http://www.w3.org/1999/02/22-rdf-syntax-ns#type")
							&& !y.attr().getRelationship().toString().contains(groupingValue))
					.map(y -> new Edge<Relation>(y.srcId(), (long) groupingId, y.attr()));
			
			// triples to keep
			JavaRDD<Edge<Relation>> keepTriplets = quadGraph.triplets().toJavaRDD()
					.filter(y -> (y.srcAttr().toString().contains(x) || y.dstAttr().toString().contains(x))
							&& (y.attr().getRelationship().toString().contains("http://www.w3.org/1999/02/22-rdf-syntax-ns#type")
							|| y.attr().getRelationship().toString().contains(groupingValue)))
					.map(y -> new Edge<Relation>(y.srcId(), y.dstId(), y.attr()));
			edges.addAll(subjectTriplets.union(objectTriplets.union(keepTriplets)).collect());
		});
		
		
		Graph<Object, Relation> graph = Graph.apply(quadGraph.vertices(),
			jsc.parallelize(edges).rdd().distinct(), "", StorageLevel.MEMORY_ONLY(), StorageLevel.MEMORY_ONLY(), objectTag,
			relationTag);
		
		return graph;
	}
